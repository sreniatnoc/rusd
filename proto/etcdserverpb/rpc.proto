syntax = "proto3";

package etcdserverpb;

import "etcdserverpb/kv.proto";
import "etcdserverpb/auth.proto";

// KV service provides key-value operations for the etcd key-value store.
service KV {
  // Range gets the keys in the range from the key-value store.
  rpc Range(RangeRequest) returns (RangeResponse);
  // Put puts the given key into the key-value store.
  // A put request increments the revision of the key-value store
  // and generates one event in the event history.
  rpc Put(PutRequest) returns (PutResponse);
  // DeleteRange deletes the given range from the key-value store.
  // A delete request increments the revision of the key-value store
  // and generates a single event in the event history for every deleted key.
  rpc DeleteRange(DeleteRangeRequest) returns (DeleteRangeResponse);
  // Txn processes multiple requests in a single transaction.
  // A txn request increments the revision of the key-value store
  // and generates events with the same revision for every completed request.
  rpc Txn(TxnRequest) returns (TxnResponse);
  // Compact compacts the event history in the etcd key-value store.
  // The server will remove historical revisions up to a given revision.
  rpc Compact(CompactionRequest) returns (CompactionResponse);
}

// Watch service provides key watching capabilities.
service Watch {
  // Watch watches for events happening or that have happened.
  // Canceling a watch request with a timeout should close
  // the server stream, immediately after which no more events should be sent.
  rpc Watch(stream WatchRequest) returns (stream WatchResponse);
}

message WatchRequest {
  // request_union is a request which is either a create, cancel, or progress.
  oneof request_union {
    WatchCreateRequest create_request = 1;
    WatchCancelRequest cancel_request = 2;
    WatchProgressRequest progress_request = 3;
  }
}

message WatchCreateRequest {
  // key is the key to watch. If the range_end is not given,
  // only the key argument is watched. Otherwise, keys in range [key, range_end) are watched.
  bytes key = 1;
  // range_end is the upper bound on the requested range [key, range_end).
  // If range_end is not given, the request only looks up key.
  bytes range_end = 2;
  // start_revision is an optional revision to watch from. No start_revision is "now".
  int64 start_revision = 3;
  // progress_notify is set so that the Watch stream will begin a new WatchResponse with the progress_notify set to true
  // when the server detects a new revision on the store discovery change.
  bool progress_notify = 4;
  // filters filter the events at server side before it sends back to the watcher.
  enum FilterType {
    NOPUT = 0;
    NODELETE = 1;
  }
  repeated FilterType filters = 5;
  // If the caller specifies watch_id, it will be used as the ID
  // for this watcher. If the id is already taken by another watcher, watch creation will fail by returning ALREADY_EXIST.
  // If the caller does not specify a watch_id, the internal arbitrary id will be used instead.
  int64 watch_id = 6;
  // fragment enables splitting large revisions into multiple watch responses.
  bool fragment = 7;
}

message WatchCancelRequest {
  // watch_id is the watch id to cancel so that no more events are sent.
  int64 watch_id = 1;
}

message WatchProgressRequest {
}

message WatchResponse {
  ResponseHeader header = 1;
  // watch_id is the watch id of the response.
  int64 watch_id = 2;
  // created is set to true if the response is for a create watch request.
  // The client should record the watch_id and expect to receive events for the created watcher.
  bool created = 3;
  // canceled is set to true if the response is for a cancel watch request.
  // No further events will be sent to this watcher.
  bool canceled = 4;
  // compact_revision is set to the minimum revision among all events within the same RPC stream.
  // When a watcher gradually falls behind the progress of the key-value store,
  // the compactor may delete watched events from the event history.
  // In that case, the watcher will be notified with a canceled WatchResponse having compact_revision set.
  // There is no need for the watcher to refresh the entire key space,
  // users can just reconnect with the compact_revision.
  int64 compact_revision = 5;
  // cancel_reason indicates the reason for cancellation.
  string cancel_reason = 6;
  // events contains all events for this watcher.
  repeated Event events = 7;
  // If the watch response has the progress_notify set as true,
  // it indicates that now server detected a new revision on this stream.
  // Clients of this streaming RPC may choose to query the progress separately.
  bool progress_notify = 8;
  // fragment indicates that event in this response is a fragment of a sepearte event.
  bool fragment = 9;
}

// Lease service provides lease operations for the etcd key-value store.
service Lease {
  // LeaseGrant creates a lease which expires if the server does not receive a keepAlive
  // request before the TTL in the request expires. All keys attached to the returned
  // lease will be deleted if the lease expires. Each expired key generates a delete event in the event history.
  rpc LeaseGrant(LeaseGrantRequest) returns (LeaseGrantResponse);
  // LeaseRevoke revokes a lease. All keys attached to the revoked lease will be deleted.
  // Every deleted key generates a delete event in the event history.
  rpc LeaseRevoke(LeaseRevokeRequest) returns (LeaseRevokeResponse);
  // LeaseKeepAlive keeps the lease alive by streaming keep alive requests from the client
  // to the server and streaming lease responses back to the client.
  rpc LeaseKeepAlive(stream LeaseKeepAliveRequest) returns (stream LeaseKeepAliveResponse);
  // LeaseTimeToLive retrieves the lease information, or the lease status if the lease is already expired.
  rpc LeaseTimeToLive(LeaseTimeToLiveRequest) returns (LeaseTimeToLiveResponse);
  // LeaseLeases lists all existing leases.
  rpc LeaseLeases(LeaseLeasesRequest) returns (LeaseLeasesResponse);
}

message LeaseGrantRequest {
  // TTL is the advisory time-to-live time of the lease unit is seconds.
  // Each request resets the TTL timer; after which the lease expires.
  int64 TTL = 1;
  // ID is the requested ID for the lease. If ID is set to 0, the lessor chooses an ID.
  int64 ID = 2;
}

message LeaseGrantResponse {
  ResponseHeader header = 1;
  // ID is the lease ID for the granted lease.
  int64 ID = 2;
  // TTL is the server chosen time-to-live time of the lease unit is seconds.
  int64 TTL = 3;
  // Error describes an error. May be empty.
  string error = 4;
}

message LeaseRevokeRequest {
  // ID is the lease ID to revoke. When the ID is revoked, all keys attached to that ID will expire.
  int64 ID = 1;
}

message LeaseRevokeResponse {
  ResponseHeader header = 1;
}

message LeaseKeepAliveRequest {
  // ID is the lease ID for which the client wishes to send a keep alive request.
  int64 ID = 1;
}

message LeaseKeepAliveResponse {
  ResponseHeader header = 1;
  // ID is the lease ID from the keep alive request.
  int64 ID = 2;
  // TTL is the new time-to-live time of the lease unit is seconds.
  int64 TTL = 3;
}

message LeaseTimeToLiveRequest {
  // ID is the lease ID for the lease.
  int64 ID = 1;
  // keys is the flag to query all the keys attached to this lease.
  bool keys = 2;
}

message LeaseTimeToLiveResponse {
  ResponseHeader header = 1;
  // ID is the lease ID from the request.
  int64 ID = 2;
  // TTL is the remaining time-to-live of the lease unit is seconds.
  int64 TTL = 3;
  // grantedTTL is the initial granted time-to-live of the lease unit is seconds.
  int64 grantedTTL = 4;
  // Keys is the list of keys attached to this lease.
  repeated bytes keys = 5;
}

message LeaseLeasesRequest {
}

message LeaseLeases {
  // ID is the lease ID returned by the sesrvice.
  int64 ID = 1;
}

message LeaseLeasesResponse {
  ResponseHeader header = 1;
  repeated LeaseLeases leases = 2;
}

// Cluster service provides operations on cluster members.
service Cluster {
  // MemberAdd adds a new member into the cluster.
  rpc MemberAdd(MemberAddRequest) returns (MemberAddResponse);
  // MemberRemove removes an existing member from the cluster.
  rpc MemberRemove(MemberRemoveRequest) returns (MemberRemoveResponse);
  // MemberUpdate updates the member configuration.
  rpc MemberUpdate(MemberUpdateRequest) returns (MemberUpdateResponse);
  // MemberList lists all the members in the cluster.
  rpc MemberList(MemberListRequest) returns (MemberListResponse);
  // MemberPromote promotes a learner member to a voting member.
  rpc MemberPromote(MemberPromoteRequest) returns (MemberPromoteResponse);
}

message Member {
  // ID is the unique identifier of the member in the cluster.
  uint64 ID = 1;
  // name is an arbitrary human-readable name for the member.
  string name = 2;
  // peerURLs is a list of URLs the member exposes to the cluster for communication.
  repeated string peerURLs = 3;
  // clientURLs is a list of URLs the member exposes to clients for communication.
  // If the member is not started, clientURLs will be empty.
  repeated string clientURLs = 4;
  // isLearner indicates if the member is raft learner.
  bool isLearner = 5;
}

message MemberAddRequest {
  // peerURLs is a list of URLs the new member will expose to the cluster for communication.
  repeated string peerURLs = 1;
  // isLearner indicates if the added member is raft learner.
  bool isLearner = 2;
}

message MemberAddResponse {
  ResponseHeader header = 1;
  // member is the member information of the added member.
  Member member = 2;
  // members is a list of all members after adding the new member.
  repeated Member members = 3;
}

message MemberRemoveRequest {
  // ID is the unique identifier of the member to remove.
  uint64 ID = 1;
}

message MemberRemoveResponse {
  ResponseHeader header = 1;
  // members is a list of all members after removing the member.
  repeated Member members = 2;
}

message MemberUpdateRequest {
  // ID is the unique identifier of the member to update.
  uint64 ID = 1;
  // clientURLs is a list of URLs the updated member exposes to clients for communication.
  repeated string clientURLs = 2;
}

message MemberUpdateResponse {
  ResponseHeader header = 1;
  // members is a list of all members after updating the member.
  repeated Member members = 2;
}

message MemberListRequest {
}

message MemberListResponse {
  ResponseHeader header = 1;
  // members is a list of all members associated with the cluster.
  repeated Member members = 2;
}

message MemberPromoteRequest {
  // ID is the unique identifier of the member to promote.
  uint64 ID = 1;
}

message MemberPromoteResponse {
  ResponseHeader header = 1;
  // members is a list of all members after promoting the member.
  repeated Member members = 2;
}

// Maintenance service provides maintenance operations for the cluster.
service Maintenance {
  // Alarm activates, deactivates, and queries alarms.
  rpc Alarm(AlarmRequest) returns (AlarmResponse);
  // Status gets the status of the member.
  rpc Status(StatusRequest) returns (StatusResponse);
  // Defragment defragments a member's backend database to recover storage space.
  rpc Defragment(DefragmentRequest) returns (DefragmentResponse);
  // Hash retrieves the hash of the KV state at the current revision
  // for consistency checking purpose.
  rpc Hash(HashRequest) returns (HashResponse);
  // HashKV retrieves the hash of all the KV's kv states,
  // the current revision, and all the keys in the KV store.
  // This method breaks down the large snapshot into smaller chunks.
  rpc HashKV(HashKVRequest) returns (HashKVResponse);
  // Snapshot sends a snapshot of the entire backend database of a member over a stream to a client.
  rpc Snapshot(SnapshotRequest) returns (stream SnapshotResponse);
  // MoveLeader requests the leader node to transfer its leadership
  // to the member with the given transferee.
  rpc MoveLeader(MoveLeaderRequest) returns (MoveLeaderResponse);
  // Downgrade advises the server to downgrade itself to the given major.minor (e.g., "3.5") version.
  rpc Downgrade(DowngradeRequest) returns (DowngradeResponse);
}

message AlarmRequest {
  enum AlarmAction {
    GET = 0;
    ACTIVATE = 1;
    DEACTIVATE = 2;
  }
  // action is the kind of alarm request to issue.
  AlarmAction action = 1;
  // memberID is the ID of the member associated with the alarm.
  uint64 memberID = 2;
  enum AlarmType {
    NONE = 0;
    NOSPACE = 1;
    CORRUPT = 2;
  }
  // alarm is the type of alarm to issue
  AlarmType alarm = 3;
}

message AlarmResponse {
  ResponseHeader header = 1;
  // alarms is a list of alarms associated with the alarm request.
  repeated KeyValuePair alarms = 2;
}

message KeyValuePair {
  bytes key = 1;
  bytes value = 2;
}

message StatusRequest {
}

message StatusResponse {
  ResponseHeader header = 1;
  // version is the cluster protocol version used by the responding member.
  string version = 2;
  // dbSize in bytes.
  int64 dbSize = 3;
  // leader is the member id of the raft leader member.
  uint64 leader = 4;
  // raftIndex is the current raft committed index.
  uint64 raftIndex = 5;
  // raftTerm is the current raft term.
  uint64 raftTerm = 6;
  // raftAppliedIndex is the current raft applied index.
  uint64 raftAppliedIndex = 7;
  // errors contains alarm/health information for the local member.
  repeated string errors = 8;
  // dbSizeInUse in bytes. the size includes the free space waiting to be compacted.
  int64 dbSizeInUse = 9;
  // isLearner indicates if the member is raft learner.
  bool isLearner = 10;
}

message DefragmentRequest {
}

message DefragmentResponse {
  ResponseHeader header = 1;
}

message HashRequest {
}

message HashResponse {
  ResponseHeader header = 1;
  // hash is the hash value computed from the KV's latest internal latest tx.
  uint32 hash = 2;
  // revision is the latest revision of the KV when the hash is calculated.
  int64 revision = 3;
}

message HashKVRequest {
  // revision is the revision for which the hash should be calculated. If the revision is zero,
  // the current revision is used.
  int64 revision = 1;
}

message HashKVResponse {
  ResponseHeader header = 1;
  // hash is the hash value computed from the KV's kv states.
  uint32 hash = 2;
  // revision is the revision from which the hash was computed.
  int64 revision = 3;
  // compact_revision is the most recent revision of the KV that is not compacted.
  int64 compact_revision = 4;
}

message SnapshotRequest {
}

message SnapshotResponse {
  // remaining_bytes is the number of byte left to send in the snapshot.
  uint64 remaining_bytes = 1;
  // blob contains the next chunk of the snapshot in the snapshot stream.
  bytes blob = 2;
}

message MoveLeaderRequest {
  // targetID is the node id for where the leader should be moved.
  uint64 targetID = 1;
}

message MoveLeaderResponse {
  ResponseHeader header = 1;
}

message DowngradeRequest {
  // targetVersion is the target version to downgrade to.
  string targetVersion = 1;
}

message DowngradeResponse {
  ResponseHeader header = 1;
}

// Auth service provides authentication and authorization operations.
service Auth {
  // AuthEnable enables authentication.
  rpc AuthEnable(AuthEnableRequest) returns (AuthEnableResponse);
  // AuthDisable disables authentication.
  rpc AuthDisable(AuthDisableRequest) returns (AuthDisableResponse);
  // AuthStatus shows the authentication status.
  rpc AuthStatus(AuthStatusRequest) returns (AuthStatusResponse);
  // Authenticate processes an authenticate request by user name/password,
  // populating a token that can be used as an authorization header.
  rpc Authenticate(AuthenticateRequest) returns (AuthenticateResponse);
  // UserAdd adds a new user.
  rpc UserAdd(AuthUserAddRequest) returns (AuthUserAddResponse);
  // UserGet gets detailed user information.
  rpc UserGet(AuthUserGetRequest) returns (AuthUserGetResponse);
  // UserList lists all users.
  rpc UserList(AuthUserListRequest) returns (AuthUserListResponse);
  // UserDelete deletes a user.
  rpc UserDelete(AuthUserDeleteRequest) returns (AuthUserDeleteResponse);
  // UserChangePassword changes a user's password.
  rpc UserChangePassword(AuthUserChangePasswordRequest) returns (AuthUserChangePasswordResponse);
  // UserGrantRole grants a role to a user.
  rpc UserGrantRole(AuthUserGrantRoleRequest) returns (AuthUserGrantRoleResponse);
  // UserRevokeRole revokes a role from a user.
  rpc UserRevokeRole(AuthUserRevokeRoleRequest) returns (AuthUserRevokeRoleResponse);
  // RoleAdd adds a new role.
  rpc RoleAdd(AuthRoleAddRequest) returns (AuthRoleAddResponse);
  // RoleGet gets detailed role information.
  rpc RoleGet(AuthRoleGetRequest) returns (AuthRoleGetResponse);
  // RoleList lists all roles.
  rpc RoleList(AuthRoleListRequest) returns (AuthRoleListResponse);
  // RoleDelete deletes a role.
  rpc RoleDelete(AuthRoleDeleteRequest) returns (AuthRoleDeleteResponse);
  // RoleGrantPermission grants a permission to a role.
  rpc RoleGrantPermission(AuthRoleGrantPermissionRequest) returns (AuthRoleGrantPermissionResponse);
  // RoleRevokePermission revokes a permission from a role.
  rpc RoleRevokePermission(AuthRoleRevokePermissionRequest) returns (AuthRoleRevokePermissionResponse);
}

message AuthEnableRequest {
}

message AuthEnableResponse {
  ResponseHeader header = 1;
}

message AuthDisableRequest {
}

message AuthDisableResponse {
  ResponseHeader header = 1;
}

message AuthStatusRequest {
}

message AuthStatusResponse {
  ResponseHeader header = 1;
  // enabled is true if authentication is enabled and false if it is disabled.
  bool enabled = 2;
  // authRevision is the current authentication revision.
  uint64 authRevision = 3;
}

message AuthenticateRequest {
  string name = 1;
  string password = 2;
}

message AuthenticateResponse {
  ResponseHeader header = 1;
  // token is an authorized token that can be used in succeeding requests for authentication.
  string token = 2;
}

message AuthUserAddRequest {
  string name = 1;
  string password = 2;
  // options is a set of options to assign to the user upon creation.
  UserAddOptions options = 3;
}

message UserAddOptions {
  // no_password is used to create a user without password and cannot authenticate.
  bool no_password = 1;
}

message AuthUserAddResponse {
  ResponseHeader header = 1;
}

message AuthUserGetRequest {
  string name = 1;
}

message AuthUserGetResponse {
  ResponseHeader header = 1;
  repeated string roles = 2;
}

message AuthUserListRequest {
}

message AuthUserListResponse {
  ResponseHeader header = 1;
  repeated string users = 2;
}

message AuthUserDeleteRequest {
  string name = 1;
}

message AuthUserDeleteResponse {
  ResponseHeader header = 1;
}

message AuthUserChangePasswordRequest {
  string name = 1;
  string password = 2;
}

message AuthUserChangePasswordResponse {
  ResponseHeader header = 1;
}

message AuthUserGrantRoleRequest {
  // user is the name of the user which should be granted a role.
  string user = 1;
  // role is the name of the role to grant to the user.
  string role = 2;
}

message AuthUserGrantRoleResponse {
  ResponseHeader header = 1;
}

message AuthUserRevokeRoleRequest {
  // name is the name of the user whose role is being revoked.
  string name = 1;
  // role is the name of the role to revoke from the user.
  string role = 2;
}

message AuthUserRevokeRoleResponse {
  ResponseHeader header = 1;
}

message AuthRoleAddRequest {
  // name is the name of the role to add to the authentication system.
  string name = 1;
}

message AuthRoleAddResponse {
  ResponseHeader header = 1;
}

message AuthRoleGetRequest {
  string role = 1;
}

message AuthRoleGetResponse {
  ResponseHeader header = 1;
  // perm is the list of permissions granted to the role.
  repeated Permission perm = 2;
}

message AuthRoleListRequest {
}

message AuthRoleListResponse {
  ResponseHeader header = 1;
  repeated string roles = 2;
}

message AuthRoleDeleteRequest {
  string role = 1;
}

message AuthRoleDeleteResponse {
  ResponseHeader header = 1;
}

message AuthRoleGrantPermissionRequest {
  // name is the name of the role which is being granted a permission.
  string name = 1;
  // perm is the permission to grant to the role.
  Permission perm = 2;
}

message AuthRoleGrantPermissionResponse {
  ResponseHeader header = 1;
}

message AuthRoleRevokePermissionRequest {
  string role = 1;
  bytes key = 2;
  bytes range_end = 3;
}

message AuthRoleRevokePermissionResponse {
  ResponseHeader header = 1;
}
